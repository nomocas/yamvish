	
main context
	each
	with
	context
	route

main router
	route

sub template : 
	if
	with
	each
	tag + derivated
	use
	client
	server
	find
	contentSwitch
	html



each(var, templ, emptyTempl)

tag(name, ?attributeMap, templ1, t2, ... )				OK	

.addCustomTag(name, defautAttrMap, templ)				OK



<uikit:flickity data-args="true, 12, '{{ hello }}'" /> 








isomorphisme : 

server : 

on doit 
- initialiser un jeu de context à chaque requete : 
		Solution :
		- soit mettre creation context principale dans fonction qui retourne nouveau context
		- soit permettre de cloner un jeu de context

	- lancer tous les call asynchrone et delay
- attendre la fin des async
- retrouver quel noeud avait quel context
- utiliser template toHTMLString ( jeu de context )


Structure Flow : 
	==> garder pure node dans parent si il y a if/each comme enfant




Context structure setters : 
	with, each, context

Node structure forker : 
	if, route(map), contentSwitch, 



si on parcours le template qu'on :
- execute tout ce qui est structurel et contextuel
- stock nouveaux contexts eventuels dans array tmp (fonction push/pop pour avoir arbre)
- stock toute fonction de rendu dans tmp



==> peut être déjà : réassocier route et context
==> quand on fait 
	==> ne se fait que sur le context ==> pas d'action sur le node courrant





var home = y()
.newContext(
	c()
	.set('searchTerm', '')
	.load('i18n', 'i18n::my-view-{{ $env.language }}.json')
	.load('campaigns', 'campaign::?match={{ searchTerm }}')
	.routeMatch('/?home/?q:query', function(matched){
		this.set('searchTerm', matched.query)
			.set('page', 'home')
			.setAsync('myCollec', c3po.get('foo::bar'));	
	})
	.each('myCollec', c().load('foo', ...))
)
.header(..., y().nav())
.section(
	y().each('myCollec', y().article(...))
)
.section(
	y().routeContent({
		'/home': y().use('api:home')
		'/bloupi':y().nav(...)
	})
)
.footer(...)




y().routedContent({
		
})

y().routedContent( {
	'/foo': y().use('...'),
	'/bar/s:flush': y().use('...')
})


y().contentSwitch('$route.page', {
	'{{ $route.bloupi === 'flup' }}':y().use('...'),
	'{{ $route.bloupi === 'flup' }}':y().use('...')
})



with/each/context :



return this.exec(
	function(){
		// to element
	}, 
	// toHTMLString
	function(){
		// should find previous created context if any
	}, 
	// toContext
	function(){
		// should produce context and traverse

	}
)







	TODO : 
		parsing 
			from DOM
				still data-*
			from String 				OK

		 .disabled 						OK

		if('!initialised', ..., ...) 		OK

		integrate filters and expressions

		request and c3po-bridge 			OK

		model validation  					OK

		route 								OK	

		views pool 							OK		

		collection filtering view 				OK

		.client( t1, t2, ...)					OK
		.server(t1, t2, ...) 					OK

		promise management : catch end render / load 		OK
		
		mount/umount event 						OK

		y.dependent('bloupi', 'foo', function(bloupi, foo){});				OK
		

		y.applyToDOM(node | selector, template)		==> apply template on dom element (select it if selector)

		eventListeners : click(addUser(user)) : should retrieve user before feeding addUser




		Template.prototype.toContext(?context)

			==> produce context tree and apply all context's vars handling




	Should :

		rename _yamvish_binds in _binds 					OK
		rename all privates vars with _*

		for each template handler : 
		add args in queue (through done) and place inner functions outside : no more closure

	Eacher : 
		==> maybe introduce special token/tag/comment for each/filter/sort 
			=> it resolves the html/js template equivalence
		e.g. 

			<div ...>
				<h1>...</h1>
				<each:users filter="name" sort="lastname">
						

				</each>
				...
				<each:events>
					

				</each>
				...
				<todo-list:todoId  />
			</div>



	ES5/6


		arrows everywhere

		arguments manip

		simple interpolation

		classes

		...
